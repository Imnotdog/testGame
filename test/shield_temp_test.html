<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<title>球體護盾（圓形擴散衝擊波）</title>
<style>
  body {
    margin:0;
    background:#000;
    display:flex;
    justify-content:center;
    align-items:center;
    height:100vh;
  }
</style>
</head>
<body>

<canvas id="c" width="650" height="650"></canvas>

<script>
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

const W = canvas.width;
const H = canvas.height;
const cx = W / 2;
const cy = H / 2;

const R_OUT = 240;
const HEX = 20;

const IMPACT_MIN_R = R_OUT - 40;
const IMPACT_MAX_R = R_OUT - 10;

const HIT_TIME = 1300;

const hits = [];

function hex(x,y,s){
  ctx.beginPath();
  for(let i=0;i<6;i++){
    const t = i*Math.PI/3 + Math.PI/6;
    ctx.lineTo(x+s*Math.cos(t), y+s*Math.sin(t));
  }
  ctx.closePath();
}

function render(){
  ctx.clearRect(0,0,W,H);

  const now = performance.now();

  ctx.save();
  const g = ctx.createRadialGradient(cx,cy,0,cx,cy,R_OUT);
  g.addColorStop(0,"rgba(20,30,60,0.7)");
  g.addColorStop(1,"rgba(0,0,0,0)");
  ctx.fillStyle = g;
  ctx.fillRect(0,0,W,H);
  ctx.restore();

  for(let i=hits.length-1;i>=0;i--){
    const h = hits[i];
    const dt = now-h.time;

    if(dt > HIT_TIME){
      hits.splice(i,1);
      continue;
    }

    const t = dt/HIT_TIME;

    drawHexGlow(h,t);
    drawCircleWave(h,t);
  }

  requestAnimationFrame(render);
}

function drawHexGlow(hit,t){
  const sqrt3 = Math.sqrt(3);
  const RANGE = 25;

  const fade = 1 - t;

  ctx.save();
  ctx.translate(cx,cy);

  ctx.beginPath();
  ctx.arc(0,0,R_OUT,0,Math.PI*2);
  ctx.closePath();
  ctx.clip();

  for(let q=-RANGE; q<=RANGE; q++){
    for(let r=-RANGE; r<=RANGE; r++){

      const x = HEX*(sqrt3*q + sqrt3/2*r);
      const y = HEX*(1.5*r);

      const d = Math.sqrt(x*x + y*y);
      if(d > R_OUT) continue;

      const dx = x - hit.ix;
      const dy = y - hit.iy;
      const dist = Math.sqrt(dx*dx + dy*dy);

      const brightness = Math.max(0, 1 - dist/160) * fade;

      if(brightness < 0.02) continue;

      ctx.strokeStyle = `rgba(150,220,255,${0.25+0.75*brightness})`;
      ctx.lineWidth = 1.3;
      hex(x,y,HEX);
      ctx.stroke();
    }
  }

  ctx.restore();
}

// ========= ★ 新版：圓形擴散衝擊波 ★ =========
function drawCircleWave(hit,t){
  const fade = 1 - t;

  const maxR = R_OUT * 1.3;
  const r = 20 + maxR * t;

  const thickness = 26;
  const innerR = Math.max(0, r - thickness);
  const outerR = r + thickness;

  ctx.save();
  ctx.translate(cx,cy);

  ctx.beginPath();
  ctx.arc(0,0,R_OUT,0,Math.PI*2);
  ctx.closePath();
  ctx.clip();

  const x0 = hit.ix;
  const y0 = hit.iy;

  const g = ctx.createRadialGradient(x0,y0,innerR, x0,y0,outerR);
  g.addColorStop(0.0, `rgba(255,255,255,${0.7*fade})`);
  g.addColorStop(0.4, `rgba(150,220,255,${0.55*fade})`);
  g.addColorStop(0.8, `rgba(40,120,255,${0.25*fade})`);
  g.addColorStop(1.0, `rgba(0,0,0,0)`);

  ctx.fillStyle = g;

  ctx.beginPath();
  ctx.arc(x0, y0, outerR, 0, Math.PI*2);
  ctx.arc(x0, y0, innerR, Math.PI*2, 0, true);
  ctx.closePath();
  ctx.fill();

  ctx.restore();
}

canvas.addEventListener("click",(e)=>{
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left - cx;
  const y = e.clientY - rect.top - cy;

  const d = Math.sqrt(x*x+y*y);
  if(d > R_OUT) return;

  const angle = Math.atan2(y,x);

  let impactR = Math.min(IMPACT_MAX_R, Math.max(IMPACT_MIN_R, d));

  const ix = Math.cos(angle)*impactR;
  const iy = Math.sin(angle)*impactR;

  hits.push({
    ix, iy,
    time: performance.now()
  });
});

render();
</script>

</body>
</html>
