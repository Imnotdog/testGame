<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<title>Torpedo VFX Test (Fireball)</title>
<style>
  body {
    margin: 0;
    overflow: hidden;
    background: #050608;
    color: #eee;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  }
  #info {
    position: fixed;
    left: 10px;
    top: 10px;
    padding: 6px 10px;
    background: rgba(0,0,0,0.5);
    border-radius: 6px;
    font-size: 14px;
  }
  canvas {
    position: absolute;
    inset: 0;
  }
</style>
</head>
<body>
<div id="info">
  左鍵點一下畫面：從下方射出一發火球魚雷<br>
  火球會沿路留下彎曲尾焰 + 粒子<br>
</div>
<canvas id="c"></canvas>

<script>
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resize();
window.addEventListener("resize", resize);

// ----------------------------
// 載入圖片（全部單張 PNG）
// ----------------------------
const ASSET = {
  body: new Image(),
  trailCore: new Image(),
  trailSoft: new Image(),
  particle: new Image(),
};

ASSET.body.src      = "../assets/effects/torpedo/torpedo_body.png";
ASSET.trailCore.src = "../assets/effects/torpedo/torpedo_trail_core.png";
ASSET.trailSoft.src = "../assets/effects/torpedo/torpedo_trail_soft.png";
ASSET.particle.src  = "../assets/effects/torpedo/torpedo_particle.png";

// ----------------------------
// Torpedo 資料結構
// ----------------------------
let torpedoes = [];

function spawnTorpedo(targetX, targetY) {
  const startX = canvas.width / 2;
  const startY = canvas.height * 0.8;

  const dx = targetX - startX;
  const dy = targetY - startY;
  const angle = Math.atan2(dy, dx);

  const speed = 650;
  const vx = Math.cos(angle) * speed;
  const vy = Math.sin(angle) * speed;

  torpedoes.push({
    x: startX,
    y: startY,
    vx, vy,
    angle,
    history: [],      // 用來做彎曲尾焰
    life: 3.0,
  });
}

// ----------------------------
// 更新
// ----------------------------
function update(dt) {
  for (const t of torpedoes) {
    t.x += t.vx * dt;
    t.y += t.vy * dt;

    // 更新 angle（確保旋轉方向正確）
    t.angle = Math.atan2(t.vy, t.vx);

    // 記錄歷史路徑
    t.history.push({ x: t.x, y: t.y });
    if (t.history.length > 30) {
      t.history.shift();
    }

    t.life -= dt;
  }

  // 移除超時或飛出畫面的
  torpedoes = torpedoes.filter(t =>
    t.life > 0 &&
    t.x > -200 && t.x < canvas.width + 200 &&
    t.y > -200 && t.y < canvas.height + 200
  );
}

// ----------------------------
// 繪製：尾焰 (Core + Soft)
// ----------------------------
function drawTrail(t) {
  const pts = t.history;
  if (pts.length < 2) return;

  ctx.save();
  ctx.globalCompositeOperation = "lighter";

  for (let i = 1; i < pts.length; i++) {
    const p  = pts[i];
    const p0 = pts[i - 1];

    const dx = p.x - p0.x;
    const dy = p.y - p0.y;
    const segLen = Math.hypot(dx, dy);
    if (segLen < 1) continue;

    const angle = Math.atan2(dy, dx);

    // 尾端更細、更透明
    const tNorm = i / (pts.length - 1);  // 0 → 尾巴, 1 → 頭
    const alpha = tNorm;                 // 越靠近頭越亮
    const widthFactor = 0.3 + 0.7 * tNorm;

    // --- 核心火柱 (trail_core) ---
    ctx.save();
    ctx.translate(p0.x, p0.y);
    ctx.rotate(angle);
    ctx.globalAlpha = alpha * 0.9;

    const coreW = segLen * 1.1;
    const coreH = 28 * widthFactor;
    ctx.drawImage(
      ASSET.trailCore,
      0, -coreH / 2,
      coreW, coreH
    );
    ctx.restore();

    // --- 柔霧火焰 (trail_soft) ---
    ctx.save();
    ctx.translate(p0.x, p0.y);
    ctx.rotate(angle);
    ctx.globalAlpha = alpha * 0.6;

    const softW = segLen * 1.3;
    const softH = 56 * widthFactor;
    ctx.drawImage(
      ASSET.trailSoft,
      -softW * 0.1, -softH / 2,
      softW, softH
    );
    ctx.restore();
  }

  ctx.restore();
}

// ----------------------------
// 繪製：粒子
// ----------------------------
function drawParticles(t) {
  ctx.save();
  ctx.globalCompositeOperation = "lighter";

  // 沿著尾焰末端隨機撒一些粒子
  const pts = t.history;
  if (pts.length < 2) return;
  const tail = pts[0];

  for (let i = 0; i < 3; i++) {
    const r = 30 + Math.random() * 40;
    const theta = Math.random() * Math.PI * 2;
    const px = tail.x + Math.cos(theta) * r;
    const py = tail.y + Math.sin(theta) * r;

    const size = 14 + Math.random() * 10;
    ctx.globalAlpha = 0.2 + Math.random() * 0.5;
    ctx.drawImage(
      ASSET.particle,
      px - size / 2,
      py - size / 2,
      size,
      size
    );
  }

  ctx.restore();
}

// ----------------------------
// 繪製：火球本體
// ----------------------------
function drawBody(t) {
  if (!ASSET.body.complete) return;

  ctx.save();
  ctx.translate(t.x, t.y);
  ctx.rotate(t.angle);
  ctx.globalAlpha = 1;

  const size = 72; // 火球大小
  ctx.drawImage(
    ASSET.body,
    -size / 2,
    -size / 2,
    size,
    size
  );

  ctx.restore();
}

// ----------------------------
// 主繪製
// ----------------------------
function render() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // 背景一點點漸層感
  const g = ctx.createRadialGradient(
    canvas.width/2, canvas.height*0.8, 0,
    canvas.width/2, canvas.height*0.8, canvas.height
  );
  g.addColorStop(0, "#220000");
  g.addColorStop(1, "#020308");
  ctx.fillStyle = g;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  for (const t of torpedoes) {
    drawTrail(t);
    drawParticles(t);
    drawBody(t);
  }
}

// ----------------------------
// Loop
// ----------------------------
let last = performance.now();
function loop(now) {
  const dt = Math.min((now - last) / 1000, 0.033);
  last = now;

  update(dt);
  render();

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// ----------------------------
// 控制：滑鼠左鍵 = 從下方射出火球
// ----------------------------
canvas.addEventListener("mousedown", e => {
  spawnTorpedo(e.clientX, e.clientY);
});
</script>
</body>
</html>
