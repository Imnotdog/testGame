<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>Top-Down Space Combat v8 (Dash Burst)</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: radial-gradient(circle at top, #141824 0, #050810 55%, #000 100%);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #f5f5f5;
    }
    #gameCanvas { position: absolute; inset: 0; display: block; }

    .hud {
      position: absolute;
      top: 10px; left: 10px;
      display: flex; flex-direction: column; gap: 8px;
      pointer-events: none;
      text-shadow: 0 0 4px #000;
      font-size: 14px;
    }
    .hud-row { display: flex; align-items: center; gap: 8px; }

    .icon {
      width: 24px; height: 24px;
      border-radius: 999px;
      background: radial-gradient(circle, #fff 0, #aaa 40%, #333 85%);
      box-shadow: 0 0 6px rgba(0,0,0,0.8);
      position: relative; overflow: hidden;
    }
    .icon.hp::before {
      content: "";
      position: absolute; inset: 3px;
      background:
        radial-gradient(circle at 30% 30%, rgba(255,255,255,0.9) 0, transparent 35%),
        radial-gradient(circle at 70% 70%, rgba(255,0,0,0.9) 0, transparent 40%),
        linear-gradient(135deg, #ff5522, #ff0033);
      clip-path: polygon(50% 5%, 90% 35%, 75% 95%, 25% 95%, 10% 35%);
    }
    .icon.shield::before {
      content: "";
      position: absolute; inset: 2px;
      background: radial-gradient(circle, #8fd6ff 0, #2575fc 40%, #020b26 85%);
      mask-image: radial-gradient(circle, #000 0, #000 55%, transparent 56%);
    }
    .icon.torp::before {
      content: "";
      position: absolute; inset: 3px;
      background:
        radial-gradient(circle at 30% 30%, #fff 0, transparent 35%),
        radial-gradient(circle at 70% 70%, #5a2bff 0, transparent 45%),
        radial-gradient(circle, #9f4bff 0, #3d0e66 60%);
    }
    .icon.laser::before {
      content: "";
      position: absolute;
      left: 50%; top: 3px;
      width: 8px; height: 18px;
      transform: translateX(-50%);
      background:
        radial-gradient(circle at 50% 0, #fff 0, #9cf 50%, transparent 70%),
        linear-gradient(to bottom, rgba(180,230,255,0.9), rgba(100,180,255,0.2));
      box-shadow: 0 0 6px rgba(150,210,255,0.9);
      border-radius: 999px;
    }

    .bar-container {
      width: 220px; height: 10px;
      border-radius: 999px;
      background: rgba(0,0,0,0.65);
      overflow: hidden;
      box-shadow:
        0 0 3px rgba(0,0,0,0.8),
        inset 0 0 4px rgba(255,255,255,0.05);
    }
    .bar-fill {
      height: 100%; width: 0%;
      border-radius: inherit;
      background: linear-gradient(90deg, #ff9966, #ff0033);
      transition: width 0.08s linear;
    }
    .bar-fill.shield { background: linear-gradient(90deg, #68e0ff, #265dff); }
    .bar-fill.torp { background: linear-gradient(90deg, #c38bff, #6f2bff); }
    .bar-fill.laser { background: linear-gradient(90deg, #b8e3ff, #3fa9ff); }

    .top-right-panel {
      position: absolute;
      top: 8px; right: 8px;
      background: rgba(5,7,15,0.9);
      border-radius: 12px;
      padding: 8px 10px;
      box-shadow: 0 0 10px rgba(0,0,0,0.9);
      display: flex; flex-direction: column; gap: 4px;
      font-size: 13px;
    }
    .top-right-panel label {
      display: flex; align-items: center; gap: 4px;
    }
    .top-right-panel select {
      background: #151a2a; color: #e9efff;
      border-radius: 8px;
      border: 1px solid #3a4a7a;
      padding: 2px 6px;
      font-size: 13px;
    }

    .mini-compass {
      position: absolute;
      right: 16px; bottom: 16px;
      width: 120px; height: 120px;
      pointer-events: none;
    }
    .mini-compass-inner {
      position: relative;
      width: 100%; height: 100%;
      border-radius: 50%;
      background:
        radial-gradient(circle at 30% 20%, rgba(255,255,255,0.16), transparent 40%),
        radial-gradient(circle at 70% 80%, rgba(115,137,255,0.5), transparent 50%),
        radial-gradient(circle, #0a0d18 0, #02040a 55%, #000 100%);
      box-shadow:
        0 0 14px rgba(0,0,0,0.9),
        0 0 10px rgba(102,153,255,0.4);
      transform: rotateX(35deg);
      transform-origin: center bottom;
      overflow: hidden;
    }
    .mini-compass-ring {
      position: absolute;
      inset: 10px;
      border-radius: 50%;
      border: 2px solid rgba(160,190,255,0.8);
      box-shadow:
        0 0 10px rgba(115,137,255,0.8),
        inset 0 0 10px rgba(50,80,180,0.7);
    }
    .mini-compass-needle {
      position: absolute;
      left: 50%; top: 50%;
      width: 0; height: 0;
      transform-origin: 50% 80%;
      transform: translate(-50%, -70%) rotate(0deg);
    }
    .mini-compass-needle::before {
      content: "";
      position: absolute;
      left: 50%; transform: translateX(-50%);
      border-left: 7px solid transparent;
      border-right: 7px solid transparent;
      border-bottom: 60px solid #ff4b4b;
      filter: drop-shadow(0 0 6px rgba(255,80,80,0.8));
    }
    .mini-compass-needle-cap {
      position: absolute;
      left: 50%; top: 50%;
      width: 18px; height: 18px;
      transform: translate(-50%, -50%);
      border-radius: 50%;
      background: radial-gradient(circle, #f5f7ff 0, #c2c9ff 45%, #13192a 80%);
      box-shadow:
        0 0 4px rgba(0,0,0,0.9),
        inset 0 0 4px rgba(0,0,0,0.7);
    }
    .mini-compass-label {
      position: absolute;
      left: 50%; bottom: 6px;
      transform: translateX(-50%);
      font-size: 11px; letter-spacing: 1px;
      text-shadow: 0 0 4px #000;
      color: #d0ddff;
    }
  </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>

<div class="hud">
  <div class="hud-row">
    <div class="icon hp"></div>
    <div class="bar-container"><div id="hpBar" class="bar-fill"></div></div>
  </div>
  <div class="hud-row">
    <div class="icon shield"></div>
    <div class="bar-container"><div id="shieldBar" class="bar-fill shield"></div></div>
  </div>
  <div class="hud-row">
    <div class="icon torp"></div>
    <div class="bar-container"><div id="torpBar" class="bar-fill torp"></div></div>
  </div>
  <div class="hud-row">
    <div class="icon laser"></div>
    <div class="bar-container"><div id="laserBar" class="bar-fill laser"></div></div>
  </div>
</div>

<div class="top-right-panel">
  <label>難度：
    <select id="difficultySelect">
      <option value="easy">簡單</option>
      <option value="normal" selected>普通</option>
      <option value="hard">困難</option>
      <option value="god">無敵模式</option>
    </select>
  </label>
  <label>文明：
    <select id="factionSelect">
      <option value="low" selected>低等文明</option>
      <option value="mid" disabled>中等文明（之後）</option>
      <option value="high" disabled>高等文明（之後）</option>
      <option value="cth" disabled>克蘇魯（之後）</option>
    </select>
  </label>
  <div id="roundLabel">回合：1</div>
</div>

<div class="mini-compass">
  <div class="mini-compass-inner">
    <div class="mini-compass-ring"></div>
    <div id="miniNeedle" class="mini-compass-needle"></div>
    <div class="mini-compass-needle-cap"></div>
    <div id="miniDirLabel" class="mini-compass-label">N</div>
  </div>
</div>

<script>
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");
  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  window.addEventListener("resize", resize);
  resize();

  const hpBar = document.getElementById("hpBar");
  const shieldBar = document.getElementById("shieldBar");
  const torpBar = document.getElementById("torpBar");
  const laserBar = document.getElementById("laserBar");
  const difficultySelect = document.getElementById("difficultySelect");
  const factionSelect = document.getElementById("factionSelect");
  const roundLabel = document.getElementById("roundLabel");
  const miniNeedle = document.getElementById("miniNeedle");
  const miniDirLabel = document.getElementById("miniDirLabel");

  const keys = {};
  const numpadPressed = new Set();
  const arrowPressed = new Set();

  const DIFFICULTY_MOD = {
    easy:   { hp: 0.75, damage: 0.7, bulletDensity: 0.6, enemySpeed: 0.7 },
    normal: { hp: 1.0,  damage: 1.0, bulletDensity: 1.0, enemySpeed: 0.85 },
    hard:   { hp: 1.25, damage: 1.3, bulletDensity: 1.2, enemySpeed: 1.0 },
    god:    { hp: 1.25, damage: 1.3, bulletDensity: 1.2, enemySpeed: 1.0 },
  };

  const ENEMY_STATS = {
    low_grunt1: { hp: 36, speed: 70, fireDelay: 2.4, damage: 10 },
    low_grunt2: { hp: 60, speed: 80, fireDelay: 2.0, damage: 10 },
    low_grunt3: { hp: 84, speed: 90, fireDelay: 2.2, damage: 12 },
  };

  const directionAnglesDeg = {
    "N": 0, "NNE": 22.5, "NE": 45, "ENE": 67.5,
    "E": 90, "ESE": 112.5, "SE": 135, "SSE": 157.5,
    "S": 180, "SSW": 202.5, "SW": 225, "WSW": 247.5,
    "W": 270, "WNW": 292.5, "NW": 315, "NNW": 337.5
  };

  const numpadDirectionMap = {
    "8": "N",
    "89": "NNE",
    "9": "NE",
    "69": "ENE",
    "6": "E",
    "36": "ESE",
    "3": "SE",
    "23": "SSE",
    "2": "S",
    "12": "SSW",
    "1": "SW",
    "14": "WSW",
    "4": "W",
    "47": "WNW",
    "7": "NW",
    "78": "NNW"
  };

  function getDirectionFromNumpad() {
    if (numpadPressed.size === 0) return null;
    const digits = Array.from(numpadPressed).filter(d => d !== "5").sort();
    if (digits.length === 0) return null;
    const key = digits.join("");
    if (numpadDirectionMap[key]) return numpadDirectionMap[key];

    if (digits.length >= 2) {
      for (let i = 0; i < digits.length; i++) {
        for (let j = i + 1; j < digits.length; j++) {
          const pair = digits[i] + digits[j];
          if (numpadDirectionMap[pair]) return numpadDirectionMap[pair];
        }
      }
    }
    if (numpadDirectionMap[digits[0]]) return numpadDirectionMap[digits[0]];
    return null;
  }

  function getDirectionFromArrows() {
    const up = arrowPressed.has("Up");
    const down = arrowPressed.has("Down");
    const left = arrowPressed.has("Left");
    const right = arrowPressed.has("Right");
    const vConflict = up && down;
    const hConflict = left && right;

    if (!vConflict && up && !hConflict && right) return "NE";
    if (!vConflict && up && !hConflict && left)  return "NW";
    if (!vConflict && down && !hConflict && right) return "SE";
    if (!vConflict && down && !hConflict && left)  return "SW";

    if (!vConflict && up && !left && !right) return "N";
    if (!vConflict && down && !left && !right) return "S";
    if (!hConflict && right && !up && !down) return "E";
    if (!hConflict && left && !up && !down) return "W";
    return null;
  }

  function dirNameToAngleRad(name) {
    if (!name) return null;
    const deg = directionAnglesDeg[name];
    if (deg == null) return null;
    return deg * Math.PI / 180;
  }

  const state = {
    lastTime: performance.now(),
    difficulty: "normal",
    faction: "low",
    round: 1,
    waveCooldown: 1.5,
    pendingNextWave: false,
    enemiesToSpawn: [],
    spawnTimer: 0,
    bullets: [],
    enemyBullets: [],
    particles: [],
    player: null,
    laser: {
      state: "idle",
      timer: 0,
      energy: 100,
      width: 10,
    }
  };

  function createPlayer() {
    const cx = canvas.width / 2;
    const cy = canvas.height * 0.7;
    return {
      x: cx, y: cy,
      angle: 0,
      targetAngle: 0,
      // 線性移動：有加速感
      moveSpeedBase: 260,
      moveSpeed: 0,
      moveSpeedMax: 360,
      moveAccel: 380,
      moveDecel: 1700,
      radius: 10,

      // 角速度：有角加速度，偏快
      angularSpeed: 0,
      angularAccel: 30.0,
      angularMaxSpeed: 9.0,
      angularDamp: 14.0,

      maxHp: 100,
      hp: 100,
      maxShield: 120,
      shield: 120,
      shieldDelay: 3.0,
      shieldDelayTimer: 0,
      shieldRegenPerSec: 12,
      invincibleTimer: 0,

      // 衝刺：使用獨立 dash 速度
      dashCooldown: 0,
      dashActive: false,
      dashTime: 0,
      dashDuration: 0.22,
      dashSpeed: 550,        // 暴衝速度（px/s）
      dashDirX: 0,
      dashDirY: 0,

      torpAmmoMax: 8,
      torpAmmo: 8,
      torpRegenPerSec: 0.6,
      torpCooldown: 0,
      flickerTimer: 0,
    };
  }

  function resetGame() {
    state.player = createPlayer();
    state.bullets = [];
    state.enemyBullets = [];
    state.enemiesToSpawn = [];
    state.particles = [];
    state.round = 1;
    state.pendingNextWave = false;
    setupWave();
  }

  function setupWave() {
    const w = canvas.width;
    const h = canvas.height;
    const difficulty = DIFFICULTY_MOD[state.difficulty];
    const baseCount = state.round === 1 ? 6 : state.round === 2 ? 9 : 12;
    const finalCount = Math.round(baseCount * difficulty.bulletDensity);

    state.enemiesToSpawn = [];
    for (let i = 0; i < finalCount; i++) {
      const typeId = i % 3 === 0 ? "low_grunt3" : (i % 2 === 0 ? "low_grunt2" : "low_grunt1");
      const side = Math.floor(Math.random() * 4);
      let ex = 0, ey = 0;
      const margin = 40;
      if (side === 0) { ex = Math.random() * w; ey = margin; }
      else if (side === 1) { ex = Math.random() * w; ey = h - margin; }
      else if (side === 2) { ex = margin; ey = Math.random() * h; }
      else { ex = w - margin; ey = Math.random() * h; }

      state.enemiesToSpawn.push({
        typeId,
        x: ex, y: ey,
        delay: Math.random() * 1.5
      });
    }
    state.spawnTimer = 0;
    state.pendingNextWave = false;
    roundLabel.textContent = `回合：${state.round}`;
  }

  const enemies = [];

  function spawnEnemy(info) {
    const base = ENEMY_STATS[info.typeId];
    if (!base) return;
    const mod = DIFFICULTY_MOD[state.difficulty];
    enemies.push({
      typeId: info.typeId,
      x: info.x, y: info.y,
      radius: 16,
      hp: base.hp * mod.hp,
      speed: base.speed * mod.enemySpeed,
      fireDelay: base.fireDelay / mod.bulletDensity,
      fireTimer: Math.random() * base.fireDelay,
      damage: base.damage * mod.damage,
      aiPhase: Math.random() * Math.PI * 2,
    });
  }

  function firePlayerTorpedo(player, angle, targetEnemy) {
    const speed = 360;
    let dirX = Math.sin(angle);
    let dirY = -Math.cos(angle);

    if (targetEnemy) {
      const dx = targetEnemy.x - player.x;
      const dy = targetEnemy.y - player.y;
      const len = Math.hypot(dx, dy) || 1;
      dirX = dx / len;
      dirY = dy / len;
    }

    const startX = player.x + dirX * 22;
    const startY = player.y + dirY * 22;

    state.bullets.push({
      from: "player",
      x: startX, y: startY,
      vx: dirX * speed,
      vy: dirY * speed,
      radius: 5,
      damage: 12,
      life: 3.0,
      angle: Math.atan2(dirY, dirX)
    });

    for (let i = 0; i < 8; i++) {
      const spread = (Math.random() - 0.5) * 0.5;
      const ang = Math.atan2(dirY, dirX) + spread;
      const s = 80 + Math.random() * 80;
      state.particles.push({
        x: startX,
        y: startY,
        vx: Math.cos(ang) * s,
        vy: Math.sin(ang) * s,
        life: 0.18 + Math.random() * 0.12,
        color: "rgba(210,170,255,",
        size: 2 + Math.random() * 2
      });
    }
  }

  function fireEnemyTorpedo(enemy, player, damage) {
    const dx = player.x - enemy.x;
    const dy = player.y - enemy.y;
    const len = Math.hypot(dx, dy) || 1;
    const dirX = dx / len;
    const dirY = dy / len;
    const speed = 190;
    state.enemyBullets.push({
      from: "enemy",
      x: enemy.x + dirX * 18,
      y: enemy.y + dirY * 18,
      vx: dirX * speed,
      vy: dirY * speed,
      radius: 3,
      damage,
      life: 4.0,
    });
  }

  function shortestAngleDiff(a, b) {
    let diff = b - a;
    while (diff > Math.PI) diff -= Math.PI * 2;
    while (diff < -Math.PI) diff += Math.PI * 2;
    return diff;
  }

  // 鍵盤事件：相反方向時只吃最後按的
  window.addEventListener("keydown", (e) => {
    if (e.repeat) return;
    keys[e.code] = true;

    if (/^Numpad[1-9]$/.test(e.code)) {
      const d = e.code.replace("Numpad", "");
      numpadPressed.add(d);
      e.preventDefault();
    }

    if (e.code === "ArrowUp")   { arrowPressed.delete("Down"); arrowPressed.add("Up");   e.preventDefault(); }
    if (e.code === "ArrowDown") { arrowPressed.delete("Up");   arrowPressed.add("Down"); e.preventDefault(); }
    if (e.code === "ArrowLeft") { arrowPressed.delete("Right");arrowPressed.add("Left"); e.preventDefault(); }
    if (e.code === "ArrowRight"){ arrowPressed.delete("Left"); arrowPressed.add("Right");e.preventDefault(); }
  });

  window.addEventListener("keyup", (e) => {
    keys[e.code] = false;
    if (/^Numpad[1-9]$/.test(e.code)) {
      const d = e.code.replace("Numpad", "");
      numpadPressed.delete(d);
      e.preventDefault();
    }
    if (e.code === "ArrowUp")   { arrowPressed.delete("Up");   e.preventDefault(); }
    if (e.code === "ArrowDown") { arrowPressed.delete("Down"); e.preventDefault(); }
    if (e.code === "ArrowLeft") { arrowPressed.delete("Left"); e.preventDefault(); }
    if (e.code === "ArrowRight"){ arrowPressed.delete("Right");e.preventDefault(); }
  });

  difficultySelect.addEventListener("change", () => {
    state.difficulty = difficultySelect.value;
    resetGame();
  });
  factionSelect.addEventListener("change", () => {
    state.faction = factionSelect.value;
    resetGame();
  });

  function update(dt) {
    const p = state.player;
    if (!p) return;

    // === 方向輸入 ===
    let dirName = null;
    if (numpadPressed.size > 0) dirName = getDirectionFromNumpad();
    else dirName = getDirectionFromArrows();

    if (dirName) {
      const angleRad = dirNameToAngleRad(dirName);
      if (angleRad != null) p.targetAngle = angleRad;
    }

    // === 角加速度轉向 ===
    const diff = shortestAngleDiff(p.angle, p.targetAngle);
    const absDiff = Math.abs(diff);
    const deadZone = 0.01;

    if (absDiff > deadZone) {
      const dir = Math.sign(diff);
      if (p.angularSpeed * dir < 0) {
        p.angularSpeed += dir * p.angularAccel * 2 * dt;
      } else {
        p.angularSpeed += dir * p.angularAccel * dt;
      }
      if (p.angularSpeed > p.angularMaxSpeed) p.angularSpeed = p.angularMaxSpeed;
      if (p.angularSpeed < -p.angularMaxSpeed) p.angularSpeed = -p.angularMaxSpeed;
    } else {
      const damp = Math.min(1, p.angularDamp * dt);
      p.angularSpeed *= (1 - damp);
      if (Math.abs(p.angularSpeed) < 0.02) p.angularSpeed = 0;
    }

    let angleStep = p.angularSpeed * dt;
    if (Math.abs(angleStep) > absDiff) {
      angleStep = diff;
      p.angularSpeed = 0;
    }
    p.angle += angleStep;

    // === 線性移動（有加速感） ===
    const isMoving = !!dirName;
    let targetSpeed = isMoving ? p.moveSpeedBase : 0;

    if (p.moveSpeed < targetSpeed) {
      p.moveSpeed = Math.min(targetSpeed, p.moveSpeed + p.moveAccel * dt);
    } else if (p.moveSpeed > targetSpeed) {
      p.moveSpeed = Math.max(targetSpeed, p.moveSpeed - p.moveDecel * dt);
    }

    let moveX = 0, moveY = 0;
    if (p.moveSpeed > 1 && isMoving) {
      const dx = Math.sin(p.angle);
      const dy = -Math.cos(p.angle);
      moveX = dx * p.moveSpeed * dt;
      moveY = dy * p.moveSpeed * dt;
    }

    // === 衝刺 (X) ：暴衝位移 ===
    if (keys["KeyX"] && p.dashCooldown <= 0 && !p.dashActive) {
      p.dashActive = true;
      p.dashTime = p.dashDuration;
      p.dashCooldown = 1.2;
      // 記錄衝刺方向（當下面向）
      p.dashDirX = Math.sin(p.angle);
      p.dashDirY = -Math.cos(p.angle);

      for (let i = 0; i < 12; i++) {
        state.particles.push({
          x: p.x, y: p.y,
          vx: (Math.random() - 0.5) * 80,
          vy: (Math.random() - 0.5) * 80,
          life: 0.3 + Math.random() * 0.2,
          color: "rgba(150,200,255,",
          size: 3 + Math.random() * 2
        });
      }
    }

    let dashX = 0, dashY = 0;
    if (p.dashActive) {
      p.dashTime -= dt;
      dashX = p.dashDirX * p.dashSpeed * dt;
      dashY = p.dashDirY * p.dashSpeed * dt;
      if (p.dashTime <= 0) p.dashActive = false;
    }
    if (p.dashCooldown > 0) p.dashCooldown -= dt;

    // === 實際位移：一般速度 + 衝刺位移 ===
    p.x += moveX + dashX;
    p.y += moveY + dashY;

    // 邊界
    if (p.x < p.radius) p.x = p.radius;
    if (p.x > canvas.width - p.radius) p.x = canvas.width - p.radius;
    if (p.y < p.radius) p.y = p.radius;
    if (p.y > canvas.height - p.radius) p.y = canvas.height - p.radius;

    // === 魚雷自動瞄準（前方 45°） ===
    function findTorpTarget() {
      if (!dirName) return null;
      const facingX = Math.sin(p.angle);
      const facingY = -Math.cos(p.angle);
      const coneCos = Math.cos(45 * Math.PI / 180);
      let best = null, bestDist = Infinity;
      for (const e of enemies) {
        const dx = e.x - p.x;
        const dy = e.y - p.y;
        const dist = Math.hypot(dx, dy);
        if (dist > 600) continue;
        const len = dist || 1;
        const ux = dx / len, uy = dy / len;
        const dot = ux * facingX + uy * facingY;
        if (dot > coneCos && dist < bestDist) {
          best = e;
          bestDist = dist;
        }
      }
      return best;
    }

    // === 魚雷 (Z) ===
    if (p.torpCooldown > 0) p.torpCooldown -= dt;
    p.torpAmmo += p.torpRegenPerSec * dt;
    if (p.torpAmmo > p.torpAmmoMax) p.torpAmmo = p.torpAmmoMax;

    if (keys["KeyZ"] && p.torpCooldown <= 0 && p.torpAmmo >= 1) {
      const target = findTorpTarget();
      firePlayerTorpedo(p, p.angle, target);
      p.torpAmmo -= 1;
      p.torpCooldown = 0.35;
    }

    // === 激光 (C) ===
    const laser = state.laser;
    laser.energy += (!keys["KeyC"] || laser.state === "idle") ? 20 * dt : 0;
    if (laser.energy > 100) laser.energy = 100;

    if (laser.state === "idle") {
      if (keys["KeyC"] && laser.energy >= 10) {
        laser.state = "charging";
        laser.timer = 0;
        laser.energy -= 10;
      }
    } else if (laser.state === "charging") {
      laser.timer += dt;
      if (!keys["KeyC"]) {
        laser.state = "release";
        laser.timer = 0;
      } else if (laser.timer >= 0.45) {
        laser.state = "firing";
        laser.timer = 0;
      }
    } else if (laser.state === "firing") {
      if (!keys["KeyC"] || laser.energy <= 0) {
        laser.state = "release";
        laser.timer = 0;
      } else {
        const drain = 35 * dt;
        laser.energy = Math.max(0, laser.energy - drain);
      }
    } else if (laser.state === "release") {
      laser.timer += dt;
      if (laser.timer >= 0.25) {
        laser.state = "idle";
        laser.timer = 0;
      }
    }

    // 激光傷害
    if (laser.state === "firing") {
      const range = 600;
      const beamWidth = 16;
      const lx = p.x, ly = p.y;
      const dx = Math.sin(p.angle);
      const dy = -Math.cos(p.angle);

      for (const e of enemies) {
        const ex = e.x - lx;
        const ey = e.y - ly;
        const proj = ex * dx + ey * dy;
        if (proj < 0 || proj > range) continue;
        const px = dx * proj;
        const py = dy * proj;
        const dist = Math.hypot(ex - px, ey - py);
        if (dist < e.radius + beamWidth) {
          const damage = 35 * dt;
          e.hp -= damage;
        }
      }
    }

    // 敵人生成 / AI
    state.spawnTimer += dt;
    for (let i = state.enemiesToSpawn.length - 1; i >= 0; i--) {
      const info = state.enemiesToSpawn[i];
      info.delay -= dt;
      if (info.delay <= 0) {
        spawnEnemy(info);
        state.enemiesToSpawn.splice(i, 1);
      }
    }

    for (const e of enemies) {
      const dx = p.x - e.x;
      const dy = p.y - e.y;
      const dist = Math.hypot(dx, dy) || 1;
      const mod = DIFFICULTY_MOD[state.difficulty];

      const towards = 1.0;
      const side = 0.4;
      const ux = dx / dist, uy = dy / dist;
      const sx = -uy, sy = ux;
      e.aiPhase += dt * 0.7;
      const sideFactor = Math.sin(e.aiPhase) * side;
      const mvx = (ux * towards + sx * sideFactor) * e.speed * dt;
      const mvy = (uy * towards + sy * sideFactor) * e.speed * dt;
      e.x += mvx; e.y += mvy;

      const margin = 20;
      if (e.x < margin) e.x = margin;
      if (e.x > canvas.width - margin) e.x = canvas.width - margin;
      if (e.y < margin) e.y = margin;
      if (e.y > canvas.height - margin) e.y = canvas.height - margin;

      e.fireTimer -= dt;
      if (e.fireTimer <= 0) {
        e.fireTimer = ENEMY_STATS[e.typeId].fireDelay / mod.bulletDensity;
        fireEnemyTorpedo(e, p, e.damage);
      }
    }

    // 子彈移動
    for (const b of state.bullets) {
      b.x += b.vx * dt;
      b.y += b.vy * dt;
      b.life -= dt;
    }
    for (const b of state.enemyBullets) {
      b.x += b.vx * dt;
      b.y += b.vy * dt;
      b.life -= dt;
    }
    state.bullets = state.bullets.filter(b =>
      b.life > 0 && b.x > -50 && b.x < canvas.width + 50 && b.y > -50 && b.y < canvas.height + 50);
    state.enemyBullets = state.enemyBullets.filter(b =>
      b.life > 0 && b.x > -50 && b.x < canvas.width + 50 && b.y > -50 && b.y < canvas.height + 50);

    // 玩家 vs 敵方子彈
    if (p.invincibleTimer > 0) p.invincibleTimer -= dt;
    for (const b of state.enemyBullets) {
      const dx = b.x - p.x;
      const dy = b.y - p.y;
      const dist = Math.hypot(dx, dy);
      if (dist < p.radius + b.radius) {
        b.life = 0;
        applyDamageToPlayer(b.damage);
      }
    }

    // 玩家 vs 敵人碰撞
    for (const e of enemies) {
      const dx = e.x - p.x;
      const dy = e.y - p.y;
      const dist = Math.hypot(dx, dy);
      const minDist = e.radius + p.radius;
      if (dist < minDist && dist > 0) {
        const nx = dx / dist;
        const ny = dy / dist;
        const overlap = minDist - dist;
        e.x += nx * overlap * 0.6;
        e.y += ny * overlap * 0.6;
        p.x -= nx * overlap * 0.4;
        p.y -= ny * overlap * 0.4;
        applyDamageToPlayer(20);
        e.hp -= 40;
      }
    }

    // 玩家魚雷 vs 敵人
    for (const b of state.bullets) {
      if (b.from !== "player") continue;
      for (const e of enemies) {
        const dx = b.x - e.x;
        const dy = b.y - e.y;
        const dist = Math.hypot(dx, dy);
        if (dist < e.radius + b.radius) {
          b.life = 0;
          e.hp -= b.damage;
          break;
        }
      }
    }

    // 敵人死亡
    for (let i = enemies.length - 1; i >= 0; i--) {
      const e = enemies[i];
      if (e.hp <= 0) {
        for (let k = 0; k < 14; k++) {
          const ang = Math.random() * Math.PI * 2;
          const spd = 60 + Math.random() * 120;
          state.particles.push({
            x: e.x, y: e.y,
            vx: Math.cos(ang) * spd,
            vy: Math.sin(ang) * spd,
            life: 0.4 + Math.random() * 0.4,
            color: "rgba(255,180,80,",
            size: 3 + Math.random() * 3
          });
        }
        enemies.splice(i, 1);
      }
    }

    // 護盾回復
    if (p.shieldDelayTimer > 0) {
      p.shieldDelayTimer -= dt;
    } else if (p.shield < p.maxShield) {
      p.shield += p.shieldRegenPerSec * dt;
      if (p.shield > p.maxShield) p.shield = p.maxShield;
    }

    // 粒子
    for (const pa of state.particles) {
      pa.x += pa.vx * dt;
      pa.y += pa.vy * dt;
      pa.life -= dt;
    }
    state.particles = state.particles.filter(pa => pa.life > 0);

    // 回合 / 波次
    if (enemies.length === 0 && state.enemiesToSpawn.length === 0 && !state.pendingNextWave) {
      state.pendingNextWave = true;
      state.waveCooldown = 2.0;
    }
    if (state.pendingNextWave) {
      state.waveCooldown -= dt;
      if (state.waveCooldown <= 0) {
        state.pendingNextWave = false;
        state.round++;
        if (state.round > 3) state.round = 1;
        setupWave();
      }
    }

    // HUD
    hpBar.style.width = (p.hp / p.maxHp * 100) + "%";
    shieldBar.style.width = (p.shield / p.maxShield * 100) + "%";
    torpBar.style.width = (p.torpAmmo / p.torpAmmoMax * 100) + "%";
    laserBar.style.width = (state.laser.energy / 100 * 100) + "%";

    // 迷你羅盤
    const deg = p.angle * 180 / Math.PI;
    miniNeedle.style.transform = `translate(-50%, -70%) rotate(${deg}deg)`;
    let nearestDir = "N", minDelta = 1e9;
    for (const [name, d] of Object.entries(directionAnglesDeg)) {
      let delta = Math.abs(((d - deg) + 540) % 360 - 180);
      if (delta < minDelta) {
        minDelta = delta;
        nearestDir = name;
      }
    }
    miniDirLabel.textContent = nearestDir;

    state.dt = dt;
  }

  function applyDamageToPlayer(dmg) {
    const p = state.player;
    if (!p) return;
    const diffMod = DIFFICULTY_MOD[state.difficulty];
    const realDmg = dmg * diffMod.damage;
    if (state.difficulty === "god") return;

    let remaining = realDmg;
    if (p.shield > 0) {
      const used = Math.min(p.shield, remaining);
      p.shield -= used;
      remaining -= used;
    }
    if (remaining > 0 && p.invincibleTimer <= 0) {
      p.hp -= remaining;
      p.invincibleTimer = 1.0;
      p.flickerTimer = 0.4;
    }
    p.shieldDelayTimer = 3.0;
    if (p.hp < 0) p.hp = 0;
  }

  function drawBackground() {
    const w = canvas.width, h = canvas.height;
    const grad = ctx.createRadialGradient(
      w * 0.3, h * 0.3, 0,
      w * 0.1, h * 0.1, Math.max(w, h)
    );
    grad.addColorStop(0, "#281b63");
    grad.addColorStop(0.3, "#0b0729");
    grad.addColorStop(0.7, "#03040a");
    grad.addColorStop(1, "#000000");
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, w, h);

    ctx.save();
    ctx.fillStyle = "white";
    for (let i = 0; i < 120; i++) {
      const x = Math.random() * w;
      const y = Math.random() * h;
      const s = Math.random() * 1.5;
      ctx.globalAlpha = 0.05;
      ctx.fillRect(x, y, s, s);
    }
    ctx.restore();
  }

  function drawParticles() {
    for (const pa of state.particles) {
      const alpha = Math.max(0, pa.life);
      ctx.fillStyle = pa.color + alpha.toFixed(2) + ")";
      ctx.beginPath();
      ctx.arc(pa.x, pa.y, pa.size, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function drawPlayer() {
    const p = state.player;
    if (!p) return;

    const flicker = p.flickerTimer > 0 && (Math.floor(p.flickerTimer * 30) % 2 === 0);
    if (p.flickerTimer > 0) p.flickerTimer -= state.dt || 0;

    if (flicker) ctx.globalAlpha = 0.3;
    ctx.save();
    ctx.translate(p.x, p.y);
    ctx.rotate(p.angle);

    const grad = ctx.createLinearGradient(0, -26, 0, 24);
    grad.addColorStop(0, "#f5f5f5");
    grad.addColorStop(0.3, "#9fa7b3");
    grad.addColorStop(0.7, "#474c57");
    grad.addColorStop(1, "#161820");
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.moveTo(0, -26);
    ctx.lineTo(12, 12);
    ctx.lineTo(6, 22);
    ctx.lineTo(-6, 22);
    ctx.lineTo(-12, 12);
    ctx.closePath();
    ctx.fill();

    ctx.strokeStyle = "rgba(166,120,255,0.9)";
    ctx.lineWidth = 1.8;
    ctx.beginPath();
    ctx.moveTo(-8, -18);
    ctx.lineTo(-14, 0);
    ctx.lineTo(-8, 16);
    ctx.moveTo(8, -18);
    ctx.lineTo(14, 0);
    ctx.lineTo(8, 16);
    ctx.stroke();

    ctx.fillStyle = "rgba(120,210,255,0.9)";
    ctx.beginPath();
    ctx.ellipse(0, 4, 4.2, 6, 0, 0, Math.PI * 2);
    ctx.fill();

    ctx.globalAlpha = 0.7;
    const flameGrad = ctx.createLinearGradient(0, 22, 0, 40);
    flameGrad.addColorStop(0, "rgba(255,220,160,1)");
    flameGrad.addColorStop(1, "rgba(255,80,0,0)");
    ctx.fillStyle = flameGrad;
    ctx.beginPath();
    ctx.moveTo(-5, 22);
    ctx.lineTo(0, 40 + Math.random() * 4);
    ctx.lineTo(5, 22);
    ctx.closePath();
    ctx.fill();

    ctx.restore();
    ctx.globalAlpha = 1.0;

    const shieldFrac = p.shield / p.maxShield;
    if (shieldFrac > 0) {
      ctx.save();
      ctx.translate(p.x, p.y);
      let alpha = 0.2 + 0.3 * shieldFrac;
      if (shieldFrac < 0.75 && shieldFrac >= 0.5) alpha *= 1.3;
      else if (shieldFrac < 0.5 && shieldFrac >= 0.25) alpha *= 1.6;
      else if (shieldFrac < 0.25) alpha *= 2.0;

      ctx.globalAlpha = alpha;
      ctx.strokeStyle = "rgba(130,200,255,0.9)";
      ctx.lineWidth = 2;
      const R = p.radius + 10;
      ctx.beginPath();
      ctx.arc(0, 0, R, 0, Math.PI * 2);
      ctx.stroke();

      ctx.globalAlpha *= 0.7;
      for (let a = 0; a < Math.PI * 2; a += Math.PI / 3) {
        ctx.beginPath();
        ctx.moveTo(Math.cos(a) * R * 0.4, Math.sin(a) * R * 0.4);
        ctx.lineTo(Math.cos(a) * R, Math.sin(a) * R);
        ctx.stroke();
      }

      if (shieldFrac < 0.5) {
        ctx.globalAlpha = 0.9;
        ctx.strokeStyle = "rgba(255,190,190,0.9)";
        const cracks = shieldFrac < 0.25 ? 7 : 3;
        for (let i = 0; i < cracks; i++) {
          const a = Math.random() * Math.PI * 2;
          const r1 = R * (0.2 + Math.random() * 0.4);
          const r2 = R * (0.5 + Math.random() * 0.4);
          ctx.beginPath();
          ctx.moveTo(Math.cos(a) * r1, Math.sin(a) * r1);
          ctx.lineTo(Math.cos(a) * r2, Math.sin(a) * r2);
          ctx.stroke();
        }
      }
      ctx.restore();
    }
  }

  function drawEnemies() {
    for (const e of enemies) {
      ctx.save();
      ctx.translate(e.x, e.y);
      const grad = ctx.createLinearGradient(-10, -10, 10, 12);
      grad.addColorStop(0, "#f1f5ff");
      grad.addColorStop(0.4, "#7d8ba5");
      grad.addColorStop(1, "#1b1d26");
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.moveTo(0, -14);
      ctx.lineTo(12, 6);
      ctx.lineTo(0, 14);
      ctx.lineTo(-12, 6);
      ctx.closePath();
      ctx.fill();

      ctx.strokeStyle = "rgba(255,180,80,0.9)";
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.arc(0, 0, 10, 0, Math.PI * 2);
      ctx.stroke();

      const baseHp = ENEMY_STATS[e.typeId].hp * DIFFICULTY_MOD[state.difficulty].hp;
      const frac = e.hp / baseHp;
      if (frac < 0.3) {
        const t = performance.now() / 100;
        const a = 0.4 + 0.4 * Math.abs(Math.sin(t));
        ctx.globalAlpha = a;
        ctx.strokeStyle = "rgba(255,80,80,1)";
        ctx.lineWidth = 2.4;
        ctx.beginPath();
        ctx.arc(0, 0, 13, 0, Math.PI * 2);
        ctx.stroke();
      }
      ctx.restore();
    }
  }

  function drawBullets() {
    for (const b of state.bullets) {
      if (b.from === "player") {
        ctx.save();
        ctx.translate(b.x, b.y);
        const ang = b.angle ?? Math.atan2(b.vy, b.vx);
        ctx.rotate(ang);

        const len = 28;
        const halfLen = len / 2;
        const halfWidth = 4;

        const gradOuter = ctx.createLinearGradient(-halfLen, 0, halfLen, 0);
        gradOuter.addColorStop(0, "rgba(130,90,255,0)");
        gradOuter.addColorStop(0.5, "rgba(210,170,255,0.7)");
        gradOuter.addColorStop(1, "rgba(130,90,255,0)");
        ctx.fillStyle = gradOuter;
        ctx.globalAlpha = 0.7;
        ctx.beginPath();
        ctx.roundRect(-halfLen, -halfWidth - 2, len, (halfWidth + 2) * 2, 6);
        ctx.fill();

        const gradCore = ctx.createLinearGradient(-halfLen, 0, halfLen, 0);
        gradCore.addColorStop(0, "rgba(255,255,255,0.2)");
        gradCore.addColorStop(0.5, "rgba(245,230,255,1)");
        gradCore.addColorStop(1, "rgba(200,180,255,0.5)");
        ctx.fillStyle = gradCore;
        ctx.globalAlpha = 1.0;
        ctx.beginPath();
        ctx.roundRect(-halfLen, -halfWidth, len, halfWidth * 2, 4);
        ctx.fill();

        ctx.globalAlpha = 0.8;
        ctx.fillStyle = "rgba(255,220,200,0.9)";
        ctx.beginPath();
        ctx.arc(-halfLen, 0, 3, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
      } else {
        ctx.save();
        ctx.fillStyle = "#ffb970";
        ctx.shadowColor = "#ffb970";
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
    }
    for (const b of state.enemyBullets) {
      ctx.save();
      ctx.fillStyle = "#ff9e5f";
      ctx.shadowColor = "#ff9e5f";
      ctx.shadowBlur = 8;
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
  }

  function drawLaser() {
    const p = state.player;
    const laser = state.laser;
    if (!p) return;
    const active = ["charging", "firing", "release"].includes(laser.state);
    if (!active) return;

    const baseAlpha =
      laser.state === "charging" ? 0.4 :
      laser.state === "firing" ? 1.0 :
      1.0 - Math.min(laser.timer / 0.25, 1.0);

    const range = 600;
    const dx = Math.sin(p.angle);
    const dy = -Math.cos(p.angle);
    const x2 = p.x + dx * range;
    const y2 = p.y + dy * range;

    ctx.save();
    ctx.globalAlpha = baseAlpha;
    ctx.lineCap = "round";

    ctx.strokeStyle = "rgba(150,210,255,0.5)";
    ctx.lineWidth = 20;
    ctx.beginPath();
    ctx.moveTo(p.x, p.y);
    ctx.lineTo(x2, y2);
    ctx.stroke();

    ctx.strokeStyle = "rgba(220,245,255,0.95)";
    ctx.lineWidth = 8;
    ctx.beginPath();
    ctx.moveTo(p.x, p.y);
    ctx.lineTo(x2, y2);
    ctx.stroke();

    const now = performance.now() / 1000;
    const orbCount = 18;
    for (let i = 0; i < orbCount; i++) {
      const t = (i / orbCount) * range;
      const px = p.x + dx * t;
      const py = p.y + dy * t;
      const phase = now * 6 + i;
      const offset = 8 + 6 * Math.sin(phase);
      const ox = -dy * offset;
      const oy = dx * offset;
      const s = 2 + 1.5 * Math.sin(phase * 2);
      ctx.beginPath();
      ctx.fillStyle = "rgba(180,230,255,0.8)";
      ctx.arc(px + ox, py + oy, s, 0, Math.PI * 2);
      ctx.fill();
    }

    ctx.restore();
  }

  function render() {
    drawBackground();
    drawParticles();
    drawLaser();
    drawBullets();
    drawEnemies();
    drawPlayer();
  }

  function loop(now) {
    const dt = Math.min((now - state.lastTime) / 1000, 0.05);
    state.lastTime = now;
    update(dt);
    render();
    requestAnimationFrame(loop);
  }

  state.difficulty = difficultySelect.value;
  state.faction = factionSelect.value;
  resetGame();
  requestAnimationFrame(loop);
</script>
</body>
</html>
